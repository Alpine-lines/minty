const { expect } = require("chai");
const { ethers } = require("hardhat");

const { setupOpenMinty, setupOpenMintyBundle } = require("../lib/setup.js");
const testVals = require("../lib/testValuesCommon.js");
const vals = require("../lib/valuesCommon.js");

/* Utility Functions */

// Not a function, the fields of the TransferSingle event.

const TRANSFER_SINGLE_FIELDS = [
    { type: "address", name: "_operator", indexed: true },
    { type: "address", name: "_from", indexed: true },
    { type: "address", name: "_to", indexed: true },
    { type: "uint256", name: "_id" },
    { type: "uint256", name: "_amount" },
];

// Not a function, the keccak of the TransferSingle event.

const TRANSFER_SINGLE_SIG = web3.eth.abi.encodeEventSignature({
    name: "TransferSingle",
    type: "event",
    inputs: TRANSFER_SINGLE_FIELDS,
});

// Total the number of tokens in the transaction's emitted TransferSingle events
// Keep a total for each token id number (1:..2:..)
// and a total for *all* tokens as total:.

const totalEventTokens = (receipt, recipient) => {
    // total is our running total for all tokens
    const totals = { total: toBN(0) };
    // Parse each log from the event
    for (let i = 0; i < receipt.receipt.rawLogs.length; i++) {
        const raw = receipt.receipt.rawLogs[i];
        // Filter events so we process only the TransferSingle events
        // Note that topic[0] is the event signature hash
        if (raw.topics[0] === TRANSFER_SINGLE_SIG) {
            // Fields of TransferSingle
            let parsed = web3.eth.abi.decodeLog(
                TRANSFER_SINGLE_FIELDS,
                raw.data,
                // Exclude event signature hash from topics that we process here.
                raw.topics.slice(1)
            );
            // Make sure the address that we are watching got the tokens.
            // Burnt tokens go to address zero, for example
            if (parsed._to == recipient) {
                // Keep a running total for each token id.
                const id = parsed._id;
                if (!totals[id]) {
                    totals[id] = toBN(0);
                }
                const amount = toBN(parsed._amount);
                totals[id] = totals[id].add(amount);
                // Keep a running total for all token ids.
                totals.total = totals.total.add(amount);
            }
        }
    }
    return totals;
};

// Compare the token amounts map generated by totalEventTokens to a spec object.
// The spec should match the guarantees[] array for the option.

const compareTokenTotals = (totals, spec, option) => {
    Object.keys(spec).forEach((key) => {
        // assert.isOk(
        // // Because it's an Object.keys() value, key is a string.
        // // We want that for the spec, as it is the correct key.
        // // But to add one we want a number, so we parse it then add one.
        // // Why do we want to add one?
        // totals[parseInt(key)] || toBN(0).gte(spec[key]),
        // `Mismatch for option ${option} guarantees[${key}]`
        // );
    });
};

/* Tests */

describe("OpenMintyBundle", (accounts) => {
    let owner;
    let userA;
    let userB;
    let proxyForOwner;

    let OpenMinty;
    let openMinty;
    let Factory;
    let myFactory;
    let Bundle;
    let myBundle;
    let Proxy;
    let proxy;

    before(async () => {
        [owner, userA, userB, proxyForOwner] = await ethers.getSigners();

        Proxy = await ethers.getContractFactory("MockProxyRegistry");
        proxy = await Proxy.deploy();
        await proxy.setProxy(owner.address, proxyForOwner.address);

        OpenMinty = await ethers.getContractFactory("OpenMinty");
        openMinty = await OpenMinty.deploy(
            "OpenMinty",
            "OMT",
            "https://example.com/contract",
            9,
            proxy.address
        );

        Factory = await ethers.getContractFactory("OpenMintyFactory");
        myFactory = await Factory.deploy(
            proxy.address,
            openMinty.address,
            "https://example.com/",
            9,
            3
        );

        Bundle = await ethers.getContractFactory("OpenMintyBundle");
        myBundle = Bundle.attach(await myFactory.bundleNftAddress());

        // await setupOpenMinty(openMinty, owner.address);

        await openMinty
            .connect(owner)
            .setApprovalForAll(myFactory.address, true);
        await openMinty.transferOwnership(myFactory.address);

        // await setupOpenMintyBundle(bundle, myFactory);
    });

    // Calls unpack()
    describe("#mint()", () => {
        it("should work for owner()", async () => {
            expect(
                await myBundle.connect(owner).unpack(vals.BUNDLE_OPTION_BASIC)
            ).to.emit(openMinty, "Transfer");

            expect(await openMinty.totalSupply()).to.equal(3);
        });

        it("should work for proxy", async () => {
            expect(
                await myBundle
                    .connect(proxyForOwner)
                    .unpack(vals.BUNDLE_OPTION_BASIC)
            ).to.emit(openMinty, "Transfer");
            expect(await openMinty.totalSupply()).to.equal(6);
        });

        it("should not work for invalid option", async () => {
            const amount = ethers.BigNumber.from(1);
            await expect(
                myBundle.connect(userA).unpack(vals.NO_SUCH_BUNDLE_OPTION)
            ).to.be.reverted;
            expect(await openMinty.totalSupply()).to.equal(6);
        });

        it("should not be able to mint more that the MAX_SUPPLY of openMinty", async () => {
            expect(
                await myBundle
                    .connect(proxyForOwner)
                    .unpack(vals.BUNDLE_OPTION_BASIC)
            ).to.emit(openMinty, "Transfer");
            expect(await openMinty.totalSupply()).to.equal(9);
            await expect(
                myBundle.connect(userA).unpack(vals.BUNDLE_OPTION_PREMIUM)
            ).to.be.reverted;
        });
    });

    describe("#unpack()", () => {
        it("should mint guaranteed class amounts for each option", async () => {
            for (let i = 0; i < vals.NUM_BUNDLE_OPTIONS; i++) {
                const option = vals.BUNDLE_OPTIONS[i];
                const amount = ethers.BigNumber.from(1);
                //console.log(i);
                // await myBundle.mint(userB, option, amount, "0x0", {
                // from: proxyForOwner,
                // });
                // const receipt = await myBundle.unpack(
                // Token IDs are option IDs
                // option,
                // userB,
                // amount,
                // { from: userB }
                // );
                // truffleAssert.eventEmitted(receipt, "BundleOpened", {
                //     boxesPurchased: amount,
                //     optionId: ethers.BigNumber.from(option),
                //     buyer: userB,
                //     itemsMinted: ethers.BigNumber.from(vals.BUNDLE_OPTION_AMOUNTS[option]),
                // });

                // const totals = totalEventTokens(receipt, userB);
                // assert.ok(
                //     totals.total.eq(ethers.BigNumber.from(vals.BUNDLE_OPTION_AMOUNTS[option]))
                // );
                // compareTokenTotals(
                //     totals,
                //     vals.BUNDLE_OPTION_GUARANTEES[option],
                //     option
                // );
            }
        });
    });
});
